#!/usr/bin/env zsh
# set $0 (ref: zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html#zero-handling)
0="${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}"
0="${${(M)0:#/*}:-$PWD/$0}"

# load library functions
source ls-colors.zsh ''

# to name the functions with a different namespace
# call source with a different argument
#source my-plugin::ls

# init (sets modecolors and namecolors)
ls-color::init
# Optional argument can be used instead of LS_COLORS
#ls-color::init "$LS_COLORS:*.md=01;03"

local file reply
# color each file in the argument list
for file; do
	ls-color::match-by $file all
	# point to symlink resolution if it exists
	print '\e['$reply[1]'m'$file'\e[0m'${reply[2]:+' → \e['$reply[2]'m'$reply[3]'\e[0m'}
done

# =======================
# Alternate manual method:
for file; do
	ls-color::match-by $file lstat follow
	if [[ $reply[2] ]]; then
		# This is a symlink
		symlink_color=$reply[1]
		# If broken, use link color for destination
		resolved_color=$reply[1]
		resolved=$reply[2]
		if [[ -e $file ]]; then
			# Not broken, update destination color
			ls-color::match-by $file stat
			resolved_color=$reply[1]
		fi
		print '\e['$symlink_color'm'$file'\e[0m → \e['$resolved_color'm'$resolved'\e[0m'
	else
		# This is not a symlink
		print '\e['$reply[1]'m'$file'\e[0m'
	fi
done

